# 如何從 SOLID 原則與設計模式中思考程式架構

在 Slack 群組上有朋友問到：「該如何學好 SOLID 原則與設計模式，如何將它們應用到實際的開發中？」

老實說，這問題其實沒有什麼標準答案，只能夠靠實戰中自己去體會。但我們可以學習何謂程式架構上設計的缺點，並試著一步步將程式重構成更良好的形式。

<!-- more -->

## 定義需求

有時候我不希望用太過於籠統的例子來說明，因為可能會造成誤解；只是要用實務專案來說明一些觀念其實不容易，因為通常它們很難涵蓋所有心法。所以這裡我來明確給個需求，讓接下來的說明有個具體的依據。

因為原來的問題中有提到「可以玩不同的遊戲」這個想法，讓我決定需求的背景如下：「我們需要一個遊戲主機，它可以執行不同類型的遊戲卡匣，這些遊戲會需要用到外部儲存媒介來記錄玩家資料。」

然後我們再定義更詳細的需求：

1. 遊戲主機可以插入遊戲卡匣。
1. 不同的遊戲卡匣存放不同類型的遊戲。
1. 遊戲主機可以插入記憶卡，讓遊戲可以存檔。

暫時就先設定這三個需求吧。

還是要提醒一下，這個需求範例並不是實務上可行的，只是為了說明而已。

## 分析程式架構如何設計

從需求中我們看到了幾個角色：

* 遊戲主機 (HomeConsole)
* 遊戲卡匣 (Cartridge)
* 遊戲 (Game)
* 記憶卡 (MemeryCard)

而我們要做的，就是定義這些對象彼此之間的互動行為。

## 第一版設計

首先遊戲主機類別一開始的設計如下：

```php
class HomeConsole
{
    /**
     * 插入卡匣與記憶卡
     */
    public function __construct(
        Cartridge $cartridge,
        MemoryCard $memoryCard
    )
    {
        $this->cartridge = $cartridge;
        $this->memoryCard = $memoryCard;
    }

    /**
     * 執行卡匣
     */
    public function run()
    {
        $this->cartridge->run();
    }
}
```

在原來的問題中，把卡匣視為一種介面，然後讓遊戲去實作：

```php
interface Cartridge
{
    public function run();
}

class Mario implements Cartridge
{
    public function run()
    {
        // 執行遊戲
    }
}
```

最後的執行方式如下：

```php
$game = new Mario();
$card = new MemoryCard();
$console = new HomeConsole($game, $card);

$console->run();
```

這設計乍看之下似乎沒什麼問題，但實務上沒那麼簡單。由於需求總是會改變，這個設計面臨了幾個問題。

### 問題一

假設有另一個賽車遊戲提供了金手指來修改存檔：

```php
class RaceCar implements Cartridge
{
    public function run()
    {
        // 執行遊戲
    }

    public function recordCheat(MemoryCard $memoryCard)
    {
        // 修改存檔
    }
}
```

這使得我們會需要直接操作該遊戲物件的方法：

```php
$game = new RaceCar();
$memoryCard = new MemoryCard();
$gamepad = new Gamepad();
$homeConsole = new HomeConsole($game, $memoryCard, $gamepad);

$homeConsole->run();
$game->recordCheat($memoryCard);
```

這個行為讓整個設計看起來是違反直觀的，為什麼遊戲卡匣會直接與記憶卡互動呢？

那麼如果讓金手指的功能放到遊戲主機類別呢？

```php

    public function recordCheat(MemoryCard $memoryCard)
    {
        // 修改存檔
    }
```


或許我們一開始就想錯了方向，不應該讓遊戲實作 Cartridge 介面。

理想的狀況是只有遊戲自己知道內部的細節，只提供唯一的介面讓遊戲主機來呼叫。

我們建立一個新的 Game 類別

### 問題二

今天如果想把存檔放在雲端上，或是想要把操作手把換成搖桿

## 第二版設計

換個想法，遊戲應該是在主機裡被執行的，所以如果需要存取記憶卡，也應該是透過主機。

```php

```






為了方便接下去說明，先假設我們的系統擁有事件回呼處理的機制吧。











從 SOLID 原則開始，我們來分析這些對象應該如何運作：

### SRP

* 遊戲執行平台：負責接收使用者的操作以執行遊戲，並提供儲存媒介給遊戲使用。

其實這問題可以從幾點來分析：

1. 額外的操作應該封裝起來，相關的類別知道就好。
2. 設計必須要先從需求面來看，
3. 不同的應用場合就延伸出不同的操作。
4. 這些不同的類別除了在測試程式外，有沒有獨立使用的機會？
5. 找出類別互動的同質性。

## Bridge Pattern

## Visitor Pattern

## Command Pattern

## 持續思考

1. 當輸入裝置換了怎麼辦？
2.

## 結語


## 進入點只會有一個

定義好 API 後，讓外部去呼叫觸發；將觸發的指令轉發給應該處理的對象，例如 Command 物件。


[設計模式的解析與活用](http://www.tenlong.com.tw/items/9862018208?item_id=886604)
