title: Dependency Injection 與 Service Locator



https://www.facebook.com/groups/laravel.tw/permalink/899759226759794/

補充一下，就自動化的角度，這例子確實不是很好。

不過我想這篇文章主要是解釋原理，所以先拋開「自動化」這件事，單就「原理」來看這兩個實現方式好了。這可以分成幾個角度來看。

從使用物件的用戶類別來看：

DI ：從外面注入符合抽象介面的物件使用。
SL ：透過鍵值在容器裡找出對應的物件來使用。

註 1 ：這裡的符合抽象介面是指繼承抽象類別或實作介面。
註 2 ：「鍵」可以是一個抽象的名稱，也可以直接用介面名稱。

從建立物件的主要類別來看：

DI ：直接 new 一個符合抽象介面的物件，並注入到用戶物件裡。
SL ：對容器註冊一個符合抽象介面的物件，但不在乎誰來使用。

以上我自認為是例子想說明的部份。

回過頭來講「自動化」這件事，兩種實作方式確實都需要容器， SL 就略過不談。如果需要讓 DI 自動化，那麼開發者就不該直接去 new 出物件，而是讓容器代勞。

在 PHP Framework 中， DI Container 會透過 Reflection 的機制來查看要注入到類別的介面有哪些，然後再透過容器去找到對應的物件，如果沒有的話自動建立一個給它使用。我寫過一篇 DI Container 實作原理，可以參考看看： http://jaceju.net/2014/07/27/php-di-container/ 。

當然我們無法直接以介面來建立物件，所以就會需要註冊介面所對應的實體物件是哪一個；這在 Java 或 C# 裡，通常是用設定檔的方式來指定。而在 Laravel 裡，通常是透過 Service Provider 來指定，再用 `Application::make()` 來建立對應的物件。

我想較完整的觀念應該是如此，以上若有誤也請不吝指正。

補充一下，就自動化的角度，這例子確實不是很好。

不過我想這篇文章主要是解釋原理，所以先拋開「自動化」這件事，單就「原理」來看這兩個實現方式好了。這可以分成幾個角度來看。

從使用物件的用戶類別來看：

DI ：從外面注入符合抽象介面的物件使用。
SL ：透過鍵值在容器裡找出對應的物件來使用。

註 1 ：這裡的符合抽象介面是指繼承抽象類別或實作介面。
註 2 ：「鍵」可以是一個抽象的名稱，也可以直接用介面名稱。

從建立物件的主要類別來看：

DI ：直接 new 一個符合抽象介面的物件，並注入到用戶物件裡。
SL ：對容器註冊一個符合抽象介面的物件，但不在乎誰來使用。

以上我自認為是例子想說明的部份。

回過頭來講「自動化」這件事，兩種實作方式確實都需要容器， SL 就略過不談。如果需要讓 DI 自動化，那麼開發者就不該直接去 new 出物件，而是讓容器代勞。

在 PHP Framework 中， DI Container 會透過 Reflection 的機制來查看要注入到類別的介面有哪些，然後再透過容器去找到對應的物件，如果沒有的話自動建立一個給它使用。我寫過一篇 DI Container 實作原理，可以參考看看： http://jaceju.net/2014/07/27/php-di-container/ 。

當然我們無法直接以介面來建立物件，所以就會需要註冊介面所對應的實體物件是哪一個；這在 Java 或 C# 裡，通常是用設定檔的方式來指定。而在 Laravel 裡，通常是透過 Service Provider 來指定，再用 Application::make() 來建立對應的物件。

我想較完整的觀念應該是如此，以上若有誤也請不吝指正。